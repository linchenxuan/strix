// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.2
// source: strix_net.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// EAsuraRetCode defines a set of standardized error codes used across the Strix framework
// for both server-side and client-side communication.
// Values 0-10000 are reserved for framework-level errors that clients must handle appropriately.
type EAsuraRetCode int32

const (
	// AsuraRetCodeOK indicates that the operation completed successfully.
	EAsuraRetCode_AsuraRetCodeOK EAsuraRetCode = 0
	// RPCDeadlineExceeded indicates that a Remote Procedure Call (RPC) exceeded its configured deadline.
	// This is typically a client-triggered error and implies the request was too slow.
	// Clients should not automatically retry this type of error; explicit retry logic is required if needed.
	EAsuraRetCode_RPCDeadlineExceeded EAsuraRetCode = 408 // Standard HTTP 408 Request Timeout code is used.
	// AsuraMax defines the upper boundary for framework-reserved error codes.
	// All error codes with a value less than or equal to AsuraMax are reserved for
	// the core Asura framework's internal use.
	EAsuraRetCode_AsuraMax EAsuraRetCode = 9999
)

// Enum value maps for EAsuraRetCode.
var (
	EAsuraRetCode_name = map[int32]string{
		0:    "AsuraRetCodeOK",
		408:  "RPCDeadlineExceeded",
		9999: "AsuraMax",
	}
	EAsuraRetCode_value = map[string]int32{
		"AsuraRetCodeOK":      0,
		"RPCDeadlineExceeded": 408,
		"AsuraMax":            9999,
	}
)

func (x EAsuraRetCode) Enum() *EAsuraRetCode {
	p := new(EAsuraRetCode)
	*p = x
	return p
}

func (x EAsuraRetCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EAsuraRetCode) Descriptor() protoreflect.EnumDescriptor {
	return file_strix_net_proto_enumTypes[0].Descriptor()
}

func (EAsuraRetCode) Type() protoreflect.EnumType {
	return &file_strix_net_proto_enumTypes[0]
}

func (x EAsuraRetCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EAsuraRetCode.Descriptor instead.
func (EAsuraRetCode) EnumDescriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{0}
}

// P2PRoute represents a point-to-point routing strategy for direct communication
// between two specific entities. This is used for targeted messaging where
// the sender knows the exact recipient's entity ID.
type P2PRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// DstEntityID is the unique identifier of the target entity for this communication.
	// This ID should be globally unique within the distributed cluster.
	DstEntityID   uint32 `protobuf:"varint,1,opt,name=DstEntityID,proto3" json:"DstEntityID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *P2PRoute) Reset() {
	*x = P2PRoute{}
	mi := &file_strix_net_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *P2PRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*P2PRoute) ProtoMessage() {}

func (x *P2PRoute) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use P2PRoute.ProtoReflect.Descriptor instead.
func (*P2PRoute) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{0}
}

func (x *P2PRoute) GetDstEntityID() uint32 {
	if x != nil {
		return x.DstEntityID
	}
	return 0
}

// RandRoute represents a random routing strategy primarily used for load distribution.
// Messages are routed to a randomly selected instance within a defined functional group,
// promoting even load balancing. It also supports deterministic routing for specific use cases.
type RandRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FuncID identifies the functional group or service type (e.g., login, matchmaking, chat)
	// to which the message should be routed.
	FuncID uint32 `protobuf:"varint,1,opt,name=FuncID,proto3" json:"FuncID,omitempty"`
	// UseConstantRoute, when true, enables deterministic routing behavior.
	// If set, the `ConstantKey` will be used to consistently route messages to the same
	// instance within the functional group, useful for testing or session stickiness.
	UseConstantRoute bool `protobuf:"varint,2,opt,name=UseConstantRoute,proto3" json:"UseConstantRoute,omitempty"`
	// ConstantKey provides a deterministic routing key when `UseConstantRoute` is true.
	// Messages with the same `FuncID` and `ConstantKey` will always be routed to the same instance.
	ConstantKey uint64 `protobuf:"varint,3,opt,name=ConstantKey,proto3" json:"ConstantKey,omitempty"`
	// AreaID specifies the target area or region for routing within the functional group.
	// This allows for geographically or logically segmented routing, directing messages
	// to instances serving a particular area (e.g., specific data centers, geographical regions).
	// When used, the random routing will only consider instances within this specified area.
	AreaID        uint32 `protobuf:"varint,4,opt,name=AreaID,proto3" json:"AreaID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandRoute) Reset() {
	*x = RandRoute{}
	mi := &file_strix_net_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandRoute) ProtoMessage() {}

func (x *RandRoute) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandRoute.ProtoReflect.Descriptor instead.
func (*RandRoute) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{1}
}

func (x *RandRoute) GetFuncID() uint32 {
	if x != nil {
		return x.FuncID
	}
	return 0
}

func (x *RandRoute) GetUseConstantRoute() bool {
	if x != nil {
		return x.UseConstantRoute
	}
	return false
}

func (x *RandRoute) GetConstantKey() uint64 {
	if x != nil {
		return x.ConstantKey
	}
	return 0
}

func (x *RandRoute) GetAreaID() uint32 {
	if x != nil {
		return x.AreaID
	}
	return 0
}

// BroadCastRoute represents a broadcast routing strategy.
// Messages are sent to all available instances within a specified functional group and area.
// This is typically used for global notifications, announcements, or state synchronization.
type BroadCastRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FuncID identifies the functional group or service type to which the broadcast message should be sent.
	FuncID uint32 `protobuf:"varint,1,opt,name=FuncID,proto3" json:"FuncID,omitempty"`
	// AreaID specifies the target area or region within the functional group for the broadcast.
	// Only instances within this specified area will receive the broadcast message.
	AreaID        uint32 `protobuf:"varint,2,opt,name=AreaID,proto3" json:"AreaID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BroadCastRoute) Reset() {
	*x = BroadCastRoute{}
	mi := &file_strix_net_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BroadCastRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BroadCastRoute) ProtoMessage() {}

func (x *BroadCastRoute) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BroadCastRoute.ProtoReflect.Descriptor instead.
func (*BroadCastRoute) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{2}
}

func (x *BroadCastRoute) GetFuncID() uint32 {
	if x != nil {
		return x.FuncID
	}
	return 0
}

func (x *BroadCastRoute) GetAreaID() uint32 {
	if x != nil {
		return x.AreaID
	}
	return 0
}

// MultiCastRoute represents a multicast routing strategy.
// Messages are sent to a predefined list of specific entity IDs.
// This allows for selective messaging to multiple, but not necessarily all, recipients.
type MultiCastRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// EntityIDs is a list of unique identifiers for the target entities that should receive the message.
	EntityIDs     []int32 `protobuf:"varint,1,rep,packed,name=EntityIDs,proto3" json:"EntityIDs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiCastRoute) Reset() {
	*x = MultiCastRoute{}
	mi := &file_strix_net_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiCastRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiCastRoute) ProtoMessage() {}

func (x *MultiCastRoute) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiCastRoute.ProtoReflect.Descriptor instead.
func (*MultiCastRoute) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{3}
}

func (x *MultiCastRoute) GetEntityIDs() []int32 {
	if x != nil {
		return x.EntityIDs
	}
	return nil
}

// InternalRoute 迁移过程中sidecar后端svr之间通信.
type InternalRoute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PipeIdx       int32                  `protobuf:"varint,1,opt,name=PipeIdx,proto3" json:"PipeIdx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InternalRoute) Reset() {
	*x = InternalRoute{}
	mi := &file_strix_net_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InternalRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InternalRoute) ProtoMessage() {}

func (x *InternalRoute) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InternalRoute.ProtoReflect.Descriptor instead.
func (*InternalRoute) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{4}
}

func (x *InternalRoute) GetPipeIdx() int32 {
	if x != nil {
		return x.PipeIdx
	}
	return 0
}

// RouteHead encapsulates all routing information necessary for message delivery
// within the Strix distributed framework. It acts as an envelope for the message,
// guiding it through the network to its ultimate destination.
type RouteHead struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SrcEntityID identifies the originating entity of the message.
	// This is crucial for response routing, logging, and audit trails.
	SrcEntityID uint32 `protobuf:"varint,1,opt,name=SrcEntityID,proto3" json:"SrcEntityID,omitempty"`
	// MsgID is the unique identifier for the type of message being sent.
	// This ID maps to specific protobuf message types and their handlers in the application layer.
	MsgID string `protobuf:"bytes,2,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	// RouteType is a oneof field, meaning exactly one of its members must be set.
	// It specifies the particular routing strategy to be applied for this message.
	//
	// Types that are valid to be assigned to RouteType:
	//
	//	*RouteHead_P2P
	//	*RouteHead_Rand
	//	*RouteHead_BroadCast
	//	*RouteHead_MultiCast
	//	*RouteHead_Internal
	RouteType isRouteHead_RouteType `protobuf_oneof:"RouteType"`
	// SrcSetVersion is the version number of the server set that originated the request.
	// This can be used for version compatibility checks in routing.
	SrcSetVersion uint64 `protobuf:"varint,8,opt,name=SrcSetVersion,proto3" json:"SrcSetVersion,omitempty"`
	// DstSetVersion specifies the target version number of the server set for routing.
	// A value of 0 indicates that no specific version is required, and any compatible version will be used.
	DstSetVersion uint64 `protobuf:"varint,9,opt,name=DstSetVersion,proto3" json:"DstSetVersion,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteHead) Reset() {
	*x = RouteHead{}
	mi := &file_strix_net_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteHead) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteHead) ProtoMessage() {}

func (x *RouteHead) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteHead.ProtoReflect.Descriptor instead.
func (*RouteHead) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{5}
}

func (x *RouteHead) GetSrcEntityID() uint32 {
	if x != nil {
		return x.SrcEntityID
	}
	return 0
}

func (x *RouteHead) GetMsgID() string {
	if x != nil {
		return x.MsgID
	}
	return ""
}

func (x *RouteHead) GetRouteType() isRouteHead_RouteType {
	if x != nil {
		return x.RouteType
	}
	return nil
}

func (x *RouteHead) GetP2P() *P2PRoute {
	if x != nil {
		if x, ok := x.RouteType.(*RouteHead_P2P); ok {
			return x.P2P
		}
	}
	return nil
}

func (x *RouteHead) GetRand() *RandRoute {
	if x != nil {
		if x, ok := x.RouteType.(*RouteHead_Rand); ok {
			return x.Rand
		}
	}
	return nil
}

func (x *RouteHead) GetBroadCast() *BroadCastRoute {
	if x != nil {
		if x, ok := x.RouteType.(*RouteHead_BroadCast); ok {
			return x.BroadCast
		}
	}
	return nil
}

func (x *RouteHead) GetMultiCast() *MultiCastRoute {
	if x != nil {
		if x, ok := x.RouteType.(*RouteHead_MultiCast); ok {
			return x.MultiCast
		}
	}
	return nil
}

func (x *RouteHead) GetInternal() *InternalRoute {
	if x != nil {
		if x, ok := x.RouteType.(*RouteHead_Internal); ok {
			return x.Internal
		}
	}
	return nil
}

func (x *RouteHead) GetSrcSetVersion() uint64 {
	if x != nil {
		return x.SrcSetVersion
	}
	return 0
}

func (x *RouteHead) GetDstSetVersion() uint64 {
	if x != nil {
		return x.DstSetVersion
	}
	return 0
}

type isRouteHead_RouteType interface {
	isRouteHead_RouteType()
}

type RouteHead_P2P struct {
	// P2P represents point-to-point routing for direct entity communication.
	P2P *P2PRoute `protobuf:"bytes,3,opt,name=P2P,proto3,oneof"`
}

type RouteHead_Rand struct {
	// Rand represents random routing for load-balanced distribution across a functional group.
	Rand *RandRoute `protobuf:"bytes,4,opt,name=Rand,proto3,oneof"`
}

type RouteHead_BroadCast struct {
	// BroadCast represents broadcast routing for sending to all instances within a functional group and area.
	BroadCast *BroadCastRoute `protobuf:"bytes,5,opt,name=BroadCast,proto3,oneof"`
}

type RouteHead_MultiCast struct {
	// MultiCast represents multicast routing for sending to a specific list of entities.
	MultiCast *MultiCastRoute `protobuf:"bytes,6,opt,name=MultiCast,proto3,oneof"`
}

type RouteHead_Internal struct {
	Internal *InternalRoute `protobuf:"bytes,7,opt,name=Internal,proto3,oneof"`
}

func (*RouteHead_P2P) isRouteHead_RouteType() {}

func (*RouteHead_Rand) isRouteHead_RouteType() {}

func (*RouteHead_BroadCast) isRouteHead_RouteType() {}

func (*RouteHead_MultiCast) isRouteHead_RouteType() {}

func (*RouteHead_Internal) isRouteHead_RouteType() {}

// PackageHead contains metadata for individual message packages, providing essential
// envelope information for message processing, routing, and error handling.
type PackageHead struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// MsgID identifies the type of message contained in the package, crucial for handler dispatch.
	MsgID string `protobuf:"bytes,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	// RetCode indicates the operation result status of the message.
	// It should typically be one of the `EAsuraRetCode` values.
	RetCode int32 `protobuf:"varint,2,opt,name=RetCode,proto3" json:"RetCode,omitempty"`
	// SvrPkgSeq is a server-side package sequence number, primarily for internal server tracking.
	// It typically starts from 1 for each server instance.
	SvrPkgSeq uint32 `protobuf:"fixed32,3,opt,name=SvrPkgSeq,proto3" json:"SvrPkgSeq,omitempty"`
	// CliPkgSeq is a client-side package sequence number, primarily for client-server synchronization.
	// It typically starts from 1 for each client connection.
	CliPkgSeq uint32 `protobuf:"fixed32,4,opt,name=CliPkgSeq,proto3" json:"CliPkgSeq,omitempty"`
	// SrcActorID identifies the originating actor or entity (e.g., player UID, room ID) of the message.
	SrcActorID uint64 `protobuf:"varint,5,opt,name=SrcActorID,proto3" json:"SrcActorID,omitempty"`
	// DstActorID identifies the target actor or entity of the message.
	DstActorID uint64 `protobuf:"varint,6,opt,name=DstActorID,proto3" json:"DstActorID,omitempty"`
	// SrcCliVersion indicates the client version of the message originator, useful for compatibility checks.
	SrcCliVersion int64             `protobuf:"varint,7,opt,name=SrcCliVersion,proto3" json:"SrcCliVersion,omitempty"`
	Meta          map[string]string `protobuf:"bytes,8,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PackageHead) Reset() {
	*x = PackageHead{}
	mi := &file_strix_net_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PackageHead) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackageHead) ProtoMessage() {}

func (x *PackageHead) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackageHead.ProtoReflect.Descriptor instead.
func (*PackageHead) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{6}
}

func (x *PackageHead) GetMsgID() string {
	if x != nil {
		return x.MsgID
	}
	return ""
}

func (x *PackageHead) GetRetCode() int32 {
	if x != nil {
		return x.RetCode
	}
	return 0
}

func (x *PackageHead) GetSvrPkgSeq() uint32 {
	if x != nil {
		return x.SvrPkgSeq
	}
	return 0
}

func (x *PackageHead) GetCliPkgSeq() uint32 {
	if x != nil {
		return x.CliPkgSeq
	}
	return 0
}

func (x *PackageHead) GetSrcActorID() uint64 {
	if x != nil {
		return x.SrcActorID
	}
	return 0
}

func (x *PackageHead) GetDstActorID() uint64 {
	if x != nil {
		return x.DstActorID
	}
	return 0
}

func (x *PackageHead) GetSrcCliVersion() int64 {
	if x != nil {
		return x.SrcCliVersion
	}
	return 0
}

func (x *PackageHead) GetMeta() map[string]string {
	if x != nil {
		return x.Meta
	}
	return nil
}

// PkgRouteHeader combines both routing information and package metadata
// into a single structure, providing a complete context for message processing
// and dispatch within the Strix framework.
type PkgRouteHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// RouteHdr contains comprehensive routing information for message delivery.
	RouteHdr *RouteHead `protobuf:"bytes,1,opt,name=RouteHdr,proto3" json:"RouteHdr,omitempty"`
	// PkgHdr contains package-level metadata for message processing and control.
	PkgHdr        *PackageHead `protobuf:"bytes,2,opt,name=PkgHdr,proto3" json:"PkgHdr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PkgRouteHeader) Reset() {
	*x = PkgRouteHeader{}
	mi := &file_strix_net_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PkgRouteHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PkgRouteHeader) ProtoMessage() {}

func (x *PkgRouteHeader) ProtoReflect() protoreflect.Message {
	mi := &file_strix_net_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PkgRouteHeader.ProtoReflect.Descriptor instead.
func (*PkgRouteHeader) Descriptor() ([]byte, []int) {
	return file_strix_net_proto_rawDescGZIP(), []int{7}
}

func (x *PkgRouteHeader) GetRouteHdr() *RouteHead {
	if x != nil {
		return x.RouteHdr
	}
	return nil
}

func (x *PkgRouteHeader) GetPkgHdr() *PackageHead {
	if x != nil {
		return x.PkgHdr
	}
	return nil
}

var File_strix_net_proto protoreflect.FileDescriptor

const file_strix_net_proto_rawDesc = "" +
	"\n" +
	"\x0fstrix_net.proto\x12\anetwork\",\n" +
	"\bP2PRoute\x12 \n" +
	"\vDstEntityID\x18\x01 \x01(\rR\vDstEntityID\"\x89\x01\n" +
	"\tRandRoute\x12\x16\n" +
	"\x06FuncID\x18\x01 \x01(\rR\x06FuncID\x12*\n" +
	"\x10UseConstantRoute\x18\x02 \x01(\bR\x10UseConstantRoute\x12 \n" +
	"\vConstantKey\x18\x03 \x01(\x04R\vConstantKey\x12\x16\n" +
	"\x06AreaID\x18\x04 \x01(\rR\x06AreaID\"@\n" +
	"\x0eBroadCastRoute\x12\x16\n" +
	"\x06FuncID\x18\x01 \x01(\rR\x06FuncID\x12\x16\n" +
	"\x06AreaID\x18\x02 \x01(\rR\x06AreaID\".\n" +
	"\x0eMultiCastRoute\x12\x1c\n" +
	"\tEntityIDs\x18\x01 \x03(\x05R\tEntityIDs\")\n" +
	"\rInternalRoute\x12\x18\n" +
	"\aPipeIdx\x18\x01 \x01(\x05R\aPipeIdx\"\x95\x03\n" +
	"\tRouteHead\x12 \n" +
	"\vSrcEntityID\x18\x01 \x01(\rR\vSrcEntityID\x12\x14\n" +
	"\x05MsgID\x18\x02 \x01(\tR\x05MsgID\x12%\n" +
	"\x03P2P\x18\x03 \x01(\v2\x11.network.P2PRouteH\x00R\x03P2P\x12(\n" +
	"\x04Rand\x18\x04 \x01(\v2\x12.network.RandRouteH\x00R\x04Rand\x127\n" +
	"\tBroadCast\x18\x05 \x01(\v2\x17.network.BroadCastRouteH\x00R\tBroadCast\x127\n" +
	"\tMultiCast\x18\x06 \x01(\v2\x17.network.MultiCastRouteH\x00R\tMultiCast\x124\n" +
	"\bInternal\x18\a \x01(\v2\x16.network.InternalRouteH\x00R\bInternal\x12$\n" +
	"\rSrcSetVersion\x18\b \x01(\x04R\rSrcSetVersion\x12$\n" +
	"\rDstSetVersion\x18\t \x01(\x04R\rDstSetVersionB\v\n" +
	"\tRouteType\"\xcc\x02\n" +
	"\vPackageHead\x12\x14\n" +
	"\x05MsgID\x18\x01 \x01(\tR\x05MsgID\x12\x18\n" +
	"\aRetCode\x18\x02 \x01(\x05R\aRetCode\x12\x1c\n" +
	"\tSvrPkgSeq\x18\x03 \x01(\aR\tSvrPkgSeq\x12\x1c\n" +
	"\tCliPkgSeq\x18\x04 \x01(\aR\tCliPkgSeq\x12\x1e\n" +
	"\n" +
	"SrcActorID\x18\x05 \x01(\x04R\n" +
	"SrcActorID\x12\x1e\n" +
	"\n" +
	"DstActorID\x18\x06 \x01(\x04R\n" +
	"DstActorID\x12$\n" +
	"\rSrcCliVersion\x18\a \x01(\x03R\rSrcCliVersion\x122\n" +
	"\x04Meta\x18\b \x03(\v2\x1e.network.PackageHead.MetaEntryR\x04Meta\x1a7\n" +
	"\tMetaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"n\n" +
	"\x0ePkgRouteHeader\x12.\n" +
	"\bRouteHdr\x18\x01 \x01(\v2\x12.network.RouteHeadR\bRouteHdr\x12,\n" +
	"\x06PkgHdr\x18\x02 \x01(\v2\x14.network.PackageHeadR\x06PkgHdr*L\n" +
	"\rEAsuraRetCode\x12\x12\n" +
	"\x0eAsuraRetCodeOK\x10\x00\x12\x18\n" +
	"\x13RPCDeadlineExceeded\x10\x98\x03\x12\r\n" +
	"\bAsuraMax\x10\x8fNB)Z'github.com/linchenxuan/strix/network/pbb\x06proto3"

var (
	file_strix_net_proto_rawDescOnce sync.Once
	file_strix_net_proto_rawDescData []byte
)

func file_strix_net_proto_rawDescGZIP() []byte {
	file_strix_net_proto_rawDescOnce.Do(func() {
		file_strix_net_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_strix_net_proto_rawDesc), len(file_strix_net_proto_rawDesc)))
	})
	return file_strix_net_proto_rawDescData
}

var file_strix_net_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_strix_net_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_strix_net_proto_goTypes = []any{
	(EAsuraRetCode)(0),     // 0: network.EAsuraRetCode
	(*P2PRoute)(nil),       // 1: network.P2PRoute
	(*RandRoute)(nil),      // 2: network.RandRoute
	(*BroadCastRoute)(nil), // 3: network.BroadCastRoute
	(*MultiCastRoute)(nil), // 4: network.MultiCastRoute
	(*InternalRoute)(nil),  // 5: network.InternalRoute
	(*RouteHead)(nil),      // 6: network.RouteHead
	(*PackageHead)(nil),    // 7: network.PackageHead
	(*PkgRouteHeader)(nil), // 8: network.PkgRouteHeader
	nil,                    // 9: network.PackageHead.MetaEntry
}
var file_strix_net_proto_depIdxs = []int32{
	1, // 0: network.RouteHead.P2P:type_name -> network.P2PRoute
	2, // 1: network.RouteHead.Rand:type_name -> network.RandRoute
	3, // 2: network.RouteHead.BroadCast:type_name -> network.BroadCastRoute
	4, // 3: network.RouteHead.MultiCast:type_name -> network.MultiCastRoute
	5, // 4: network.RouteHead.Internal:type_name -> network.InternalRoute
	9, // 5: network.PackageHead.Meta:type_name -> network.PackageHead.MetaEntry
	6, // 6: network.PkgRouteHeader.RouteHdr:type_name -> network.RouteHead
	7, // 7: network.PkgRouteHeader.PkgHdr:type_name -> network.PackageHead
	8, // [8:8] is the sub-list for method output_type
	8, // [8:8] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_strix_net_proto_init() }
func file_strix_net_proto_init() {
	if File_strix_net_proto != nil {
		return
	}
	file_strix_net_proto_msgTypes[5].OneofWrappers = []any{
		(*RouteHead_P2P)(nil),
		(*RouteHead_Rand)(nil),
		(*RouteHead_BroadCast)(nil),
		(*RouteHead_MultiCast)(nil),
		(*RouteHead_Internal)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_strix_net_proto_rawDesc), len(file_strix_net_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_strix_net_proto_goTypes,
		DependencyIndexes: file_strix_net_proto_depIdxs,
		EnumInfos:         file_strix_net_proto_enumTypes,
		MessageInfos:      file_strix_net_proto_msgTypes,
	}.Build()
	File_strix_net_proto = out.File
	file_strix_net_proto_goTypes = nil
	file_strix_net_proto_depIdxs = nil
}
