# `shm` 包

`shm` 包提供了一套用于管理和选择共享内存通信管道的机制。它允许多个进程在多个共享内存管道中安全地选择一个可用的管道进行通信，并处理进程异常退出导致死锁的问题。

## 核心功能

- **共享内存管道选择**: 从一组管道中选择一个当前可用的管道。
- **管道锁定**: 使用文件锁来声明对特定管道的所有权。
- **状态检查**: 查询所有管道的当前状态（例如，是否被锁定，锁是否过期）。
- **锁续期**: 允许持有锁的进程定期更新锁的过期时间，以表明其仍在活动。
- **死锁处理**: 通过锁的过期时间机制，避免因进程崩溃未释放锁而导致的永久性死锁。

## 工作原理

本机制的核心是基于文件锁。每个共享内存管道都对应一个锁文件。

- **锁定**: 当一个进程需要使用某个管道时，它会去获取对应文件的排他锁。成功获取锁后，它会将自己的版本信息和锁的过期时间写入该文件。
- **选择**: 当一个新进程需要选择一个管道时，它会遍历所有的锁文件：
    1. 尝试获取文件锁。如果无法获取，说明该管道正被另一个进程使用。
    2. 如果获取成功，则读取文件内容。
    3. 检查锁的过期时间。如果锁已过期，即使文件被锁定了，也认为该管道是可用的（因为持有锁的进程可能已经崩溃）。
    4. 根据版本信息和可用性，选择一个最合适的管道。
- **续期**: 成功锁定一个管道的进程会启动一个goroutine，定期更新锁文件中的过期时间，以防止其他进程认为该锁已失效而抢占管道。

## 主要函数

- `(s *ShmpipeSelector) LockShmpipe(shmDir, lockFileName string, pipeIdx int, v uint64) error`
  - 锁定一个指定的共享内存管道。`pipeIdx` 是管道的索引，`v` 是代表当前进程的版本/标识。

- `(s *ShmpipeSelector) RenewShmpipePeriodically(ctx context.Context, stopRecv chan bool)`
  - 启动一个goroutine，在给定的`context`下，周期性地为已锁定的管道续期。

- `GetAvailableShmpipeIdx(shmDir, lockFileName string, pipeCnt int, v uint64) int`
  - 检查所有管道的状态，并返回一个可用的管道索引。

- `(s *ShmpipeSelector) UnlockShmPipe() error`
  - 释放当前持有的管道锁。
